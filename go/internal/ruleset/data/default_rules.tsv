id	langs	description	category	severity	problem_summary	fix_hint
perf_avoid_string_concat_loop	go,rust	Avoid string concatenation in loops; use builders or reserved buffers	memory	warning	Repeated string concatenation inside loops reallocates and copies growing buffers.	Use strings.Builder or String::with_capacity, grow once, and append within the loop.
perf_regex_compile_once	go	Compile regular expressions once instead of inside hot loops	cpu	warning	Compiling a regexp each iteration reparses the pattern and dominates CPU time.	Precompile via regexp.MustCompile outside the loop and reuse the compiled matcher.
perf_preallocate_collections	go,rust	Preallocate slices, vectors, and maps when the final size is predictable	allocation	warning	Letting collections grow unchecked triggers repeated allocations and rehashes.	Call make/with_capacity or reserve the expected length before pushing items.
perf_avoid_reflection_dynamic	go,rust	Avoid reflection in Go and dynamic dispatch in Rust hot paths	runtime	high	Reflection or dyn dispatch in hot loops blocks inlining and adds heap churn.	Use concrete types or hoist dynamic lookups outside the loop to reuse resolved handles.
perf_bound_concurrency	go,rust	Bound concurrency with worker pools or async limits to prevent oversubscription	concurrency	error	Spawning unbounded work can exhaust CPU, memory, and OS descriptors.	Run tasks through worker pools, semaphores, or bounded executors to cap concurrency.
perf_borrow_instead_of_clone	rust	Prefer borrowing instead of cloning to avoid unnecessary allocations	allocation	high	Loop-local clones copy data and allocate even when a borrow would suffice.	Pass references or restructure ownership so the loop reuses the source value without cloning.
perf_equal_fold_compare	go	Use strings.EqualFold instead of strings.ToLower or strings.ToUpper for comparisons	string	info	Normalizing both sides creates new strings and scans the data twice.	Call strings.EqualFold for case-insensitive equality to avoid allocations.
perf_vec_reserve_capacity	rust	Reserve capacity on vectors built inside deterministic loops	allocation	warning	Vec growth without reserves reallocates and copies as the loop progresses.	Initialize vectors with Vec::with_capacity or reserve_exact before pushing items.
perf_syncpool_store_pointers	go	Store pointer types in sync.Pool to avoid interface allocation churn	allocation	medium	Putting values (not pointers) in sync.Pool copies on every get/put and defeats pooling.	Pool pointer types so objects stay on the heap and can be reused without copying.
perf_writer_prefer_bytes	go	Write byte slices directly instead of converting to strings	io	info	Casting []byte to string for writes forces an allocation and byte copy.	Pass []byte directly to io.Writer.Write or use bytes.Buffer without string conversions.
perf_avoid_linked_list	go,rust	Avoid linked lists for general-purpose sequence storage	data-structure	warning	container/list and LinkedList chase pointers and miss caches compared to slices or Vec.	Use slices, Vec, or VecDeque unless random mid-list insertion dominates the workload.
perf_large_enum_variant	rust	Keep enum variants similarly sized to avoid bloating every instance	memory	warning	An oversized enum variant forces every value of the enum to reserve that payload size on stack and heap.	Move the bulky payload behind Box or split it into a separate struct referenced by the enum.
perf_unnecessary_arc	rust	Avoid Arc<T> when data never leaves a single thread	concurrency	medium	Arc performs atomic ref counts even when T is not Send + Sync, adding overhead without safety gains.	Use Rc<T> or plain ownership when data stays on one thread, or refactor to borrow instead of cloning Arcs.
perf_atomic_for_small_lock	go,rust	Prefer atomics over mutexes when guarding a lone primitive	concurrency	warning	Locking sync.Mutex or std::sync::Mutex just to flip a bool/counter adds contention and kernel coordination.	Replace the mutex with the matching atomic type (sync/atomic or std::sync::atomic) so updates stay lock-free.
perf_no_defer_in_loop	go	Avoid defer statements inside hot loops	runtime	warning	Each loop-level defer allocates a record and delays cleanup until the function returns, piling up work.	Call the cleanup directly per iteration or move the defer outside the loop scope so work happens immediately.
perf_avoid_rune_conversion	go	Iterate strings directly instead of converting to []rune	string	info	[]rune(str) copies the full string before the loop, wasting time and memory just to read runes.	Use `for _, r := range str` to stream runes without allocating a temporary slice.
perf_needless_collect	rust	Avoid collect::<Vec<_>>() when immediately deriving simple info	allocation	warning	Collecting an iterator just to call len/iter/is_empty builds an unnecessary Vec and churns the heap.	Use iterator adapters like count(), any(), nth(), or for_each to derive the result without allocating.
perf_use_buffered_io	go	Batch small I/O with bufio instead of per-byte syscalls	io	warning	Writing tiny chunks straight to os.File or net.Conn issues a syscall per byte and tanks throughput.	Wrap the stream with bufio.Reader/Writer or aggregate bytes in a buffer before issuing writes.
perf_prefer_stack_alloc	go,rust	Keep small Copy-sized structs on the stack instead of heap indirection	allocation	medium	Heap allocating tiny structs adds malloc/free and pointer chasing when a value copy would fit in registers.	Pass and store the value directly or embed it in the parent struct so it stays on the stack.
